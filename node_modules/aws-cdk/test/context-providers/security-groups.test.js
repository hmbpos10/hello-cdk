"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk-mock");
const security_groups_1 = require("../../lib/context-providers/security-groups");
const mock_sdk_1 = require("../util/mock-sdk");
AWS.setSDK(require.resolve('aws-sdk'));
const mockSDK = new mock_sdk_1.MockSdkProvider();
afterEach(done => {
    AWS.restore();
    done();
});
describe('security group context provider plugin', () => {
    test('errors when no matches are found', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            cb(null, { SecurityGroups: [] });
        });
        // WHEN
        await expect(provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
        })).rejects.toThrow(/No security groups found/i);
    });
    test('looks up by security group id', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({ GroupIds: ['sg-1234'] });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '0.0.0.0/0' },
                                ],
                            },
                            {
                                IpProtocol: '-1',
                                Ipv6Ranges: [
                                    { CidrIpv6: '::/0' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        const res = await provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
        });
        // THEN
        expect(res.securityGroupId).toEqual('sg-1234');
        expect(res.allowAllOutbound).toEqual(true);
    });
    test('looks up by security group id and vpc id', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({
                GroupIds: ['sg-1234'],
                Filters: [
                    {
                        Name: 'vpc-id',
                        Values: ['vpc-1234567'],
                    },
                ],
            });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '0.0.0.0/0' },
                                ],
                            },
                            {
                                IpProtocol: '-1',
                                Ipv6Ranges: [
                                    { CidrIpv6: '::/0' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        const res = await provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
            vpcId: 'vpc-1234567',
        });
        // THEN
        expect(res.securityGroupId).toEqual('sg-1234');
        expect(res.allowAllOutbound).toEqual(true);
    });
    test('looks up by security group name', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({
                Filters: [
                    {
                        Name: 'group-name',
                        Values: ['my-security-group'],
                    },
                ],
            });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '0.0.0.0/0' },
                                ],
                            },
                            {
                                IpProtocol: '-1',
                                Ipv6Ranges: [
                                    { CidrIpv6: '::/0' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        const res = await provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupName: 'my-security-group',
        });
        // THEN
        expect(res.securityGroupId).toEqual('sg-1234');
        expect(res.allowAllOutbound).toEqual(true);
    });
    test('looks up by security group name and vpc id', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({
                Filters: [
                    {
                        Name: 'vpc-id',
                        Values: ['vpc-1234567'],
                    },
                    {
                        Name: 'group-name',
                        Values: ['my-security-group'],
                    },
                ],
            });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '0.0.0.0/0' },
                                ],
                            },
                            {
                                IpProtocol: '-1',
                                Ipv6Ranges: [
                                    { CidrIpv6: '::/0' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        const res = await provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupName: 'my-security-group',
            vpcId: 'vpc-1234567',
        });
        // THEN
        expect(res.securityGroupId).toEqual('sg-1234');
        expect(res.allowAllOutbound).toEqual(true);
    });
    test('detects non all-outbound egress', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({ GroupIds: ['sg-1234'] });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '10.0.0.0/16' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        const res = await provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
        });
        // THEN
        expect(res.securityGroupId).toEqual('sg-1234');
        expect(res.allowAllOutbound).toEqual(false);
    });
    test('errors when more than one security group is found', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        AWS.mock('EC2', 'describeSecurityGroups', (_params, cb) => {
            expect(_params).toEqual({ GroupIds: ['sg-1234'] });
            cb(null, {
                SecurityGroups: [
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '10.0.0.0/16' },
                                ],
                            },
                        ],
                    },
                    {
                        GroupId: 'sg-1234',
                        IpPermissionsEgress: [
                            {
                                IpProtocol: '-1',
                                IpRanges: [
                                    { CidrIp: '10.0.0.0/16' },
                                ],
                            },
                        ],
                    },
                ],
            });
        });
        // WHEN
        await expect(provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
        })).rejects.toThrow(/\More than one security groups found matching/i);
    });
    test('errors when securityGroupId and securityGroupName are specified both', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        // WHEN
        await expect(provider.getValue({
            account: '1234',
            region: 'us-east-1',
            securityGroupId: 'sg-1234',
            securityGroupName: 'my-security-group',
        })).rejects.toThrow(/\'securityGroupId\' and \'securityGroupName\' can not be specified both when looking up a security group/i);
    });
    test('errors when neither securityGroupId nor securityGroupName are specified', async () => {
        // GIVEN
        const provider = new security_groups_1.SecurityGroupContextProviderPlugin(mockSDK);
        // WHEN
        await expect(provider.getValue({
            account: '1234',
            region: 'us-east-1',
        })).rejects.toThrow(/\'securityGroupId\' or \'securityGroupName\' must be specified to look up a security group/i);
    });
    test('identifies allTrafficEgress from SecurityGroup permissions', () => {
        expect((0, security_groups_1.hasAllTrafficEgress)({
            IpPermissionsEgress: [
                {
                    IpProtocol: '-1',
                    IpRanges: [
                        { CidrIp: '0.0.0.0/0' },
                    ],
                },
                {
                    IpProtocol: '-1',
                    Ipv6Ranges: [
                        { CidrIpv6: '::/0' },
                    ],
                },
            ],
        })).toBe(true);
    });
    test('identifies allTrafficEgress from SecurityGroup permissions when combined', () => {
        expect((0, security_groups_1.hasAllTrafficEgress)({
            IpPermissionsEgress: [
                {
                    IpProtocol: '-1',
                    IpRanges: [
                        { CidrIp: '0.0.0.0/0' },
                    ],
                    Ipv6Ranges: [
                        { CidrIpv6: '::/0' },
                    ],
                },
            ],
        })).toBe(true);
    });
    test('identifies lacking allTrafficEgress from SecurityGroup permissions', () => {
        expect((0, security_groups_1.hasAllTrafficEgress)({
            IpPermissionsEgress: [
                {
                    IpProtocol: '-1',
                    IpRanges: [
                        { CidrIp: '10.0.0.0/16' },
                    ],
                },
            ],
        })).toBe(false);
        expect((0, security_groups_1.hasAllTrafficEgress)({
            IpPermissions: [
                {
                    IpProtocol: 'TCP',
                    IpRanges: [
                        { CidrIp: '0.0.0.0/0' },
                    ],
                },
            ],
        })).toBe(false);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjdXJpdHktZ3JvdXBzLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzZWN1cml0eS1ncm91cHMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLG9DQUFvQztBQUNwQyxpRkFBc0g7QUFDdEgsK0NBQW1EO0FBRW5ELEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBRXZDLE1BQU0sT0FBTyxHQUFHLElBQUksMEJBQWUsRUFBRSxDQUFDO0FBSXRDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNmLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNkLElBQUksRUFBRSxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsd0NBQXdDLEVBQUUsR0FBRyxFQUFFO0lBQ3RELElBQUksQ0FBQyxrQ0FBa0MsRUFBRSxLQUFLLElBQUksRUFBRTtRQUNsRCxRQUFRO1FBQ1IsTUFBTSxRQUFRLEdBQUcsSUFBSSxvREFBa0MsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVqRSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSx3QkFBd0IsRUFBRSxDQUFDLE9BQThDLEVBQUUsRUFBcUQsRUFBRSxFQUFFO1lBQ2xKLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNuQyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU87UUFDUCxNQUFNLE1BQU0sQ0FDVixRQUFRLENBQUMsUUFBUSxDQUFDO1lBQ2hCLE9BQU8sRUFBRSxNQUFNO1lBQ2YsTUFBTSxFQUFFLFdBQVc7WUFDbkIsZUFBZSxFQUFFLFNBQVM7U0FDM0IsQ0FBQyxDQUNILENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0lBQ2pELENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLCtCQUErQixFQUFFLEtBQUss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bSAnYXdzLXNkayc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkay1tb2NrJztcbmltcG9ydCB7IGhhc0FsbFRyYWZmaWNFZ3Jlc3MsIFNlY3VyaXR5R3JvdXBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi8uLi9saWIvY29udGV4dC1wcm92aWRlcnMvc2VjdXJpdHktZ3JvdXBzJztcbmltcG9ydCB7IE1vY2tTZGtQcm92aWRlciB9IGZyb20gJy4uL3V0aWwvbW9jay1zZGsnO1xuXG5BV1Muc2V0U0RLKHJlcXVpcmUucmVzb2x2ZSgnYXdzLXNkaycpKTtcblxuY29uc3QgbW9ja1NESyA9IG5ldyBNb2NrU2RrUHJvdmlkZXIoKTtcblxudHlwZSBBd3NDYWxsYmFjazxUPiA9IChlcnI6IEVycm9yIHwgbnVsbCwgdmFsOiBUKSA9PiB2b2lkO1xuXG5hZnRlckVhY2goZG9uZSA9PiB7XG4gIEFXUy5yZXN0b3JlKCk7XG4gIGRvbmUoKTtcbn0pO1xuXG5kZXNjcmliZSgnc2VjdXJpdHkgZ3JvdXAgY29udGV4dCBwcm92aWRlciBwbHVnaW4nLCAoKSA9PiB7XG4gIHRlc3QoJ2Vycm9ycyB3aGVuIG5vIG1hdGNoZXMgYXJlIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2VjdXJpdHlHcm91cENvbnRleHRQcm92aWRlclBsdWdpbihtb2NrU0RLKTtcblxuICAgIEFXUy5tb2NrKCdFQzInLCAnZGVzY3JpYmVTZWN1cml0eUdyb3VwcycsIChfcGFyYW1zOiBhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXF1ZXN0LCBjYjogQXdzQ2FsbGJhY2s8YXdzLkVDMi5EZXNjcmliZVNlY3VyaXR5R3JvdXBzUmVzdWx0PikgPT4ge1xuICAgICAgY2IobnVsbCwgeyBTZWN1cml0eUdyb3VwczogW10gfSk7XG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgYXdhaXQgZXhwZWN0KFxuICAgICAgcHJvdmlkZXIuZ2V0VmFsdWUoe1xuICAgICAgICBhY2NvdW50OiAnMTIzNCcsXG4gICAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAgICAgIHNlY3VyaXR5R3JvdXBJZDogJ3NnLTEyMzQnLFxuICAgICAgfSksXG4gICAgKS5yZWplY3RzLnRvVGhyb3coL05vIHNlY3VyaXR5IGdyb3VwcyBmb3VuZC9pKTtcbiAgfSk7XG5cbiAgdGVzdCgnbG9va3MgdXAgYnkgc2VjdXJpdHkgZ3JvdXAgaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBTZWN1cml0eUdyb3VwQ29udGV4dFByb3ZpZGVyUGx1Z2luKG1vY2tTREspO1xuXG4gICAgQVdTLm1vY2soJ0VDMicsICdkZXNjcmliZVNlY3VyaXR5R3JvdXBzJywgKF9wYXJhbXM6IGF3cy5FQzIuRGVzY3JpYmVTZWN1cml0eUdyb3Vwc1JlcXVlc3QsIGNiOiBBd3NDYWxsYmFjazxhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXN1bHQ+KSA9PiB7XG4gICAgICBleHBlY3QoX3BhcmFtcykudG9FcXVhbCh7IEdyb3VwSWRzOiBbJ3NnLTEyMzQnXSB9KTtcbiAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgU2VjdXJpdHlHcm91cHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgICAgICAgICBJcFBlcm1pc3Npb25zRWdyZXNzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBJcFByb3RvY29sOiAnLTEnLFxuICAgICAgICAgICAgICAgIElwUmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcDogJzAuMC4wLjAvMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgICAgICBJcHY2UmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcHY2OiAnOjovMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuZ2V0VmFsdWUoe1xuICAgICAgYWNjb3VudDogJzEyMzQnLFxuICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICAgIHNlY3VyaXR5R3JvdXBJZDogJ3NnLTEyMzQnLFxuICAgIH0pO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChyZXMuc2VjdXJpdHlHcm91cElkKS50b0VxdWFsKCdzZy0xMjM0Jyk7XG4gICAgZXhwZWN0KHJlcy5hbGxvd0FsbE91dGJvdW5kKS50b0VxdWFsKHRydWUpO1xuICB9KTtcblxuICB0ZXN0KCdsb29rcyB1cCBieSBzZWN1cml0eSBncm91cCBpZCBhbmQgdnBjIGlkJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2VjdXJpdHlHcm91cENvbnRleHRQcm92aWRlclBsdWdpbihtb2NrU0RLKTtcblxuICAgIEFXUy5tb2NrKCdFQzInLCAnZGVzY3JpYmVTZWN1cml0eUdyb3VwcycsIChfcGFyYW1zOiBhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXF1ZXN0LCBjYjogQXdzQ2FsbGJhY2s8YXdzLkVDMi5EZXNjcmliZVNlY3VyaXR5R3JvdXBzUmVzdWx0PikgPT4ge1xuICAgICAgZXhwZWN0KF9wYXJhbXMpLnRvRXF1YWwoe1xuICAgICAgICBHcm91cElkczogWydzZy0xMjM0J10sXG4gICAgICAgIEZpbHRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBOYW1lOiAndnBjLWlkJyxcbiAgICAgICAgICAgIFZhbHVlczogWyd2cGMtMTIzNDU2NyddLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgU2VjdXJpdHlHcm91cHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgICAgICAgICBJcFBlcm1pc3Npb25zRWdyZXNzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBJcFByb3RvY29sOiAnLTEnLFxuICAgICAgICAgICAgICAgIElwUmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcDogJzAuMC4wLjAvMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgICAgICBJcHY2UmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcHY2OiAnOjovMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuZ2V0VmFsdWUoe1xuICAgICAgYWNjb3VudDogJzEyMzQnLFxuICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICAgIHNlY3VyaXR5R3JvdXBJZDogJ3NnLTEyMzQnLFxuICAgICAgdnBjSWQ6ICd2cGMtMTIzNDU2NycsXG4gICAgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHJlcy5zZWN1cml0eUdyb3VwSWQpLnRvRXF1YWwoJ3NnLTEyMzQnKTtcbiAgICBleHBlY3QocmVzLmFsbG93QWxsT3V0Ym91bmQpLnRvRXF1YWwodHJ1ZSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2xvb2tzIHVwIGJ5IHNlY3VyaXR5IGdyb3VwIG5hbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBTZWN1cml0eUdyb3VwQ29udGV4dFByb3ZpZGVyUGx1Z2luKG1vY2tTREspO1xuXG4gICAgQVdTLm1vY2soJ0VDMicsICdkZXNjcmliZVNlY3VyaXR5R3JvdXBzJywgKF9wYXJhbXM6IGF3cy5FQzIuRGVzY3JpYmVTZWN1cml0eUdyb3Vwc1JlcXVlc3QsIGNiOiBBd3NDYWxsYmFjazxhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXN1bHQ+KSA9PiB7XG4gICAgICBleHBlY3QoX3BhcmFtcykudG9FcXVhbCh7XG4gICAgICAgIEZpbHRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBOYW1lOiAnZ3JvdXAtbmFtZScsXG4gICAgICAgICAgICBWYWx1ZXM6IFsnbXktc2VjdXJpdHktZ3JvdXAnXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIFNlY3VyaXR5R3JvdXBzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgR3JvdXBJZDogJ3NnLTEyMzQnLFxuICAgICAgICAgICAgSXBQZXJtaXNzaW9uc0VncmVzczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgICAgICBJcFJhbmdlczogW1xuICAgICAgICAgICAgICAgICAgeyBDaWRySXA6ICcwLjAuMC4wLzAnIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIElwUHJvdG9jb2w6ICctMScsXG4gICAgICAgICAgICAgICAgSXB2NlJhbmdlczogW1xuICAgICAgICAgICAgICAgICAgeyBDaWRySXB2NjogJzo6LzAnIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHByb3ZpZGVyLmdldFZhbHVlKHtcbiAgICAgIGFjY291bnQ6ICcxMjM0JyxcbiAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAgICBzZWN1cml0eUdyb3VwTmFtZTogJ215LXNlY3VyaXR5LWdyb3VwJyxcbiAgICB9KTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3QocmVzLnNlY3VyaXR5R3JvdXBJZCkudG9FcXVhbCgnc2ctMTIzNCcpO1xuICAgIGV4cGVjdChyZXMuYWxsb3dBbGxPdXRib3VuZCkudG9FcXVhbCh0cnVlKTtcbiAgfSk7XG5cbiAgdGVzdCgnbG9va3MgdXAgYnkgc2VjdXJpdHkgZ3JvdXAgbmFtZSBhbmQgdnBjIGlkJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2VjdXJpdHlHcm91cENvbnRleHRQcm92aWRlclBsdWdpbihtb2NrU0RLKTtcblxuICAgIEFXUy5tb2NrKCdFQzInLCAnZGVzY3JpYmVTZWN1cml0eUdyb3VwcycsIChfcGFyYW1zOiBhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXF1ZXN0LCBjYjogQXdzQ2FsbGJhY2s8YXdzLkVDMi5EZXNjcmliZVNlY3VyaXR5R3JvdXBzUmVzdWx0PikgPT4ge1xuICAgICAgZXhwZWN0KF9wYXJhbXMpLnRvRXF1YWwoe1xuICAgICAgICBGaWx0ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgTmFtZTogJ3ZwYy1pZCcsXG4gICAgICAgICAgICBWYWx1ZXM6IFsndnBjLTEyMzQ1NjcnXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIE5hbWU6ICdncm91cC1uYW1lJyxcbiAgICAgICAgICAgIFZhbHVlczogWydteS1zZWN1cml0eS1ncm91cCddLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgU2VjdXJpdHlHcm91cHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgICAgICAgICBJcFBlcm1pc3Npb25zRWdyZXNzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBJcFByb3RvY29sOiAnLTEnLFxuICAgICAgICAgICAgICAgIElwUmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcDogJzAuMC4wLjAvMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgICAgICBJcHY2UmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcHY2OiAnOjovMCcgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuZ2V0VmFsdWUoe1xuICAgICAgYWNjb3VudDogJzEyMzQnLFxuICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICAgIHNlY3VyaXR5R3JvdXBOYW1lOiAnbXktc2VjdXJpdHktZ3JvdXAnLFxuICAgICAgdnBjSWQ6ICd2cGMtMTIzNDU2NycsXG4gICAgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHJlcy5zZWN1cml0eUdyb3VwSWQpLnRvRXF1YWwoJ3NnLTEyMzQnKTtcbiAgICBleHBlY3QocmVzLmFsbG93QWxsT3V0Ym91bmQpLnRvRXF1YWwodHJ1ZSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2RldGVjdHMgbm9uIGFsbC1vdXRib3VuZCBlZ3Jlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBTZWN1cml0eUdyb3VwQ29udGV4dFByb3ZpZGVyUGx1Z2luKG1vY2tTREspO1xuXG4gICAgQVdTLm1vY2soJ0VDMicsICdkZXNjcmliZVNlY3VyaXR5R3JvdXBzJywgKF9wYXJhbXM6IGF3cy5FQzIuRGVzY3JpYmVTZWN1cml0eUdyb3Vwc1JlcXVlc3QsIGNiOiBBd3NDYWxsYmFjazxhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXN1bHQ+KSA9PiB7XG4gICAgICBleHBlY3QoX3BhcmFtcykudG9FcXVhbCh7IEdyb3VwSWRzOiBbJ3NnLTEyMzQnXSB9KTtcbiAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgU2VjdXJpdHlHcm91cHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgICAgICAgICBJcFBlcm1pc3Npb25zRWdyZXNzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBJcFByb3RvY29sOiAnLTEnLFxuICAgICAgICAgICAgICAgIElwUmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICB7IENpZHJJcDogJzEwLjAuMC4wLzE2JyB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBwcm92aWRlci5nZXRWYWx1ZSh7XG4gICAgICBhY2NvdW50OiAnMTIzNCcsXG4gICAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgICAgc2VjdXJpdHlHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHJlcy5zZWN1cml0eUdyb3VwSWQpLnRvRXF1YWwoJ3NnLTEyMzQnKTtcbiAgICBleHBlY3QocmVzLmFsbG93QWxsT3V0Ym91bmQpLnRvRXF1YWwoZmFsc2UpO1xuICB9KTtcblxuICB0ZXN0KCdlcnJvcnMgd2hlbiBtb3JlIHRoYW4gb25lIHNlY3VyaXR5IGdyb3VwIGlzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2VjdXJpdHlHcm91cENvbnRleHRQcm92aWRlclBsdWdpbihtb2NrU0RLKTtcblxuICAgIEFXUy5tb2NrKCdFQzInLCAnZGVzY3JpYmVTZWN1cml0eUdyb3VwcycsIChfcGFyYW1zOiBhd3MuRUMyLkRlc2NyaWJlU2VjdXJpdHlHcm91cHNSZXF1ZXN0LCBjYjogQXdzQ2FsbGJhY2s8YXdzLkVDMi5EZXNjcmliZVNlY3VyaXR5R3JvdXBzUmVzdWx0PikgPT4ge1xuICAgICAgZXhwZWN0KF9wYXJhbXMpLnRvRXF1YWwoeyBHcm91cElkczogWydzZy0xMjM0J10gfSk7XG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIFNlY3VyaXR5R3JvdXBzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgR3JvdXBJZDogJ3NnLTEyMzQnLFxuICAgICAgICAgICAgSXBQZXJtaXNzaW9uc0VncmVzczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgICAgICBJcFJhbmdlczogW1xuICAgICAgICAgICAgICAgICAgeyBDaWRySXA6ICcxMC4wLjAuMC8xNicgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEdyb3VwSWQ6ICdzZy0xMjM0JyxcbiAgICAgICAgICAgIElwUGVybWlzc2lvbnNFZ3Jlc3M6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIElwUHJvdG9jb2w6ICctMScsXG4gICAgICAgICAgICAgICAgSXBSYW5nZXM6IFtcbiAgICAgICAgICAgICAgICAgIHsgQ2lkcklwOiAnMTAuMC4wLjAvMTYnIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFdIRU5cbiAgICBhd2FpdCBleHBlY3QoXG4gICAgICBwcm92aWRlci5nZXRWYWx1ZSh7XG4gICAgICAgIGFjY291bnQ6ICcxMjM0JyxcbiAgICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICAgICAgc2VjdXJpdHlHcm91cElkOiAnc2ctMTIzNCcsXG4gICAgICB9KSxcbiAgICApLnJlamVjdHMudG9UaHJvdygvXFxNb3JlIHRoYW4gb25lIHNlY3VyaXR5IGdyb3VwcyBmb3VuZCBtYXRjaGluZy9pKTtcbiAgfSk7XG5cbiAgdGVzdCgnZXJyb3JzIHdoZW4gc2VjdXJpdHlHcm91cElkIGFuZCBzZWN1cml0eUdyb3VwTmFtZSBhcmUgc3BlY2lmaWVkIGJvdGgnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBTZWN1cml0eUdyb3VwQ29udGV4dFByb3ZpZGVyUGx1Z2luKG1vY2tTREspO1xuXG4gICAgLy8gV0hFTlxuICAgIGF3YWl0IGV4cGVjdChcbiAgICAgIHByb3ZpZGVyLmdldFZhbHVlKHtcbiAgICAgICAgYWNjb3VudDogJzEyMzQnLFxuICAgICAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgICAgICBzZWN1cml0eUdyb3VwSWQ6ICdzZy0xMjM0JyxcbiAgICAgICAgc2VjdXJpdHlHcm91cE5hbWU6ICdteS1zZWN1cml0eS1ncm91cCcsXG4gICAgICB9KSxcbiAgICApLnJlamVjdHMudG9UaHJvdygvXFwnc2VjdXJpdHlHcm91cElkXFwnIGFuZCBcXCdzZWN1cml0eUdyb3VwTmFtZVxcJyBjYW4gbm90IGJlIHNwZWNpZmllZCBib3RoIHdoZW4gbG9va2luZyB1cCBhIHNlY3VyaXR5IGdyb3VwL2kpO1xuICB9KTtcblxuICB0ZXN0KCdlcnJvcnMgd2hlbiBuZWl0aGVyIHNlY3VyaXR5R3JvdXBJZCBub3Igc2VjdXJpdHlHcm91cE5hbWUgYXJlIHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFNlY3VyaXR5R3JvdXBDb250ZXh0UHJvdmlkZXJQbHVnaW4obW9ja1NESyk7XG5cbiAgICAvLyBXSEVOXG4gICAgYXdhaXQgZXhwZWN0KFxuICAgICAgcHJvdmlkZXIuZ2V0VmFsdWUoe1xuICAgICAgICBhY2NvdW50OiAnMTIzNCcsXG4gICAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAgICB9KSxcbiAgICApLnJlamVjdHMudG9UaHJvdygvXFwnc2VjdXJpdHlHcm91cElkXFwnIG9yIFxcJ3NlY3VyaXR5R3JvdXBOYW1lXFwnIG11c3QgYmUgc3BlY2lmaWVkIHRvIGxvb2sgdXAgYSBzZWN1cml0eSBncm91cC9pKTtcbiAgfSk7XG5cbiAgdGVzdCgnaWRlbnRpZmllcyBhbGxUcmFmZmljRWdyZXNzIGZyb20gU2VjdXJpdHlHcm91cCBwZXJtaXNzaW9ucycsICgpID0+IHtcbiAgICBleHBlY3QoXG4gICAgICBoYXNBbGxUcmFmZmljRWdyZXNzKHtcbiAgICAgICAgSXBQZXJtaXNzaW9uc0VncmVzczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIElwUHJvdG9jb2w6ICctMScsXG4gICAgICAgICAgICBJcFJhbmdlczogW1xuICAgICAgICAgICAgICB7IENpZHJJcDogJzAuMC4wLjAvMCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBJcFByb3RvY29sOiAnLTEnLFxuICAgICAgICAgICAgSXB2NlJhbmdlczogW1xuICAgICAgICAgICAgICB7IENpZHJJcHY2OiAnOjovMCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgdGVzdCgnaWRlbnRpZmllcyBhbGxUcmFmZmljRWdyZXNzIGZyb20gU2VjdXJpdHlHcm91cCBwZXJtaXNzaW9ucyB3aGVuIGNvbWJpbmVkJywgKCkgPT4ge1xuICAgIGV4cGVjdChcbiAgICAgIGhhc0FsbFRyYWZmaWNFZ3Jlc3Moe1xuICAgICAgICBJcFBlcm1pc3Npb25zRWdyZXNzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgSXBQcm90b2NvbDogJy0xJyxcbiAgICAgICAgICAgIElwUmFuZ2VzOiBbXG4gICAgICAgICAgICAgIHsgQ2lkcklwOiAnMC4wLjAuMC8wJyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIElwdjZSYW5nZXM6IFtcbiAgICAgICAgICAgICAgeyBDaWRySXB2NjogJzo6LzAnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICApLnRvQmUodHJ1ZSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2lkZW50aWZpZXMgbGFja2luZyBhbGxUcmFmZmljRWdyZXNzIGZyb20gU2VjdXJpdHlHcm91cCBwZXJtaXNzaW9ucycsICgpID0+IHtcbiAgICBleHBlY3QoXG4gICAgICBoYXNBbGxUcmFmZmljRWdyZXNzKHtcbiAgICAgICAgSXBQZXJtaXNzaW9uc0VncmVzczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIElwUHJvdG9jb2w6ICctMScsXG4gICAgICAgICAgICBJcFJhbmdlczogW1xuICAgICAgICAgICAgICB7IENpZHJJcDogJzEwLjAuMC4wLzE2JyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgKS50b0JlKGZhbHNlKTtcblxuICAgIGV4cGVjdChcbiAgICAgIGhhc0FsbFRyYWZmaWNFZ3Jlc3Moe1xuICAgICAgICBJcFBlcm1pc3Npb25zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgSXBQcm90b2NvbDogJ1RDUCcsXG4gICAgICAgICAgICBJcFJhbmdlczogW1xuICAgICAgICAgICAgICB7IENpZHJJcDogJzAuMC4wLjAvMCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICkudG9CZShmYWxzZSk7XG4gIH0pO1xufSk7XG4iXX0=